<!DOCTYPE html>
<html dir="ltr" class="client-js" lang="en"><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<title>Memory Allocation - OSDev Wiki</title>
<meta charset="UTF-8">
<meta name="generator" content="MediaWiki 1.18.0">
<link rel="shortcut icon" href="http://wiki.osdev.org/favicon.ico">
<link rel="search" type="application/opensearchdescription+xml" href="http://wiki.osdev.org/opensearch_desc.php" title="OSDev Wiki (en)">
<link rel="EditURI" type="application/rsd+xml" href="http://wiki.osdev.org/api.php?action=rsd">
<link rel="alternate" type="application/atom+xml" title="OSDev Wiki Atom feed" href="http://wiki.osdev.org/index.php?title=Special:RecentChanges&amp;feed=atom">
<link rel="stylesheet" href="Memory%20Allocation%20-%20OSDev%20Wiki_files/load.css">
<style type="text/css" media="all">.mw-collapsible-toggle{float:right} li .mw-collapsible-toggle{float:none} .mw-collapsible-toggle-li{list-style:none}

/* cache key: wikidb:resourceloader:filter:minify-css:4:4250852ed2349a0d4d0fc6509a3e7d4c */
</style><style type="text/css" media="all">.js-messagebox{margin:1em 5%;padding:0.5em 2.5%;border:1px solid #ccc;background-color:#fcfcfc;font-size:0.8em}.js-messagebox .js-messagebox-group{margin:1px;padding:0.5em 2.5%;border-bottom:1px solid #ddd}.js-messagebox .js-messagebox-group:last-child{border-bottom:thin none transparent}

/* cache key: wikidb:resourceloader:filter:minify-css:4:8b08bdc91c52a9ffba396dccfb5b473c */
</style><meta name="ResourceLoaderDynamicStyles" content="">
<link rel="stylesheet" href="Memory%20Allocation%20-%20OSDev%20Wiki_files/load_002.css">
<style>a:lang(ar),a:lang(ckb),a:lang(fa),a:lang(kk-arab),a:lang(mzn),a:lang(ps),a:lang(ur){text-decoration:none}a.new,#quickbar a.new{color:#ba0000}

/* cache key: wikidb:resourceloader:filter:minify-css:4:c88e2bcd56513749bec09a7e29cb3ffa */
</style>
<script src="Memory%20Allocation%20-%20OSDev%20Wiki_files/load_003.php"></script><script src="Memory%20Allocation%20-%20OSDev%20Wiki_files/load_002.php"></script>
<script>if(window.mw){
	mw.config.set({"wgCanonicalNamespace": "", "wgCanonicalSpecialPageName": false, "wgNamespaceNumber": 0, "wgPageName": "Memory_Allocation", "wgTitle": "Memory Allocation", "wgCurRevisionId": 13057, "wgArticleId": 1460, "wgIsArticle": true, "wgAction": "view", "wgUserName": null, "wgUserGroups": ["*"], "wgCategories": ["Memory management"], "wgBreakFrames": false, "wgRestrictionEdit": [], "wgRestrictionMove": []});
}
</script><script>if(window.mw){
	mw.loader.load(["mediawiki.page.startup"]);
}
</script><script type="text/javascript" src="Memory%20Allocation%20-%20OSDev%20Wiki_files/load.php"></script>
<!--[if lt IE 7]><style type="text/css">body{behavior:url("/skins/vector/csshover.min.htc")}</style><![endif]--></head>
<body class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-Memory_Allocation action-view skin-vector">
		<div id="mw-page-base" class="noprint"></div>
		<div id="mw-head-base" class="noprint"></div>
		<!-- content -->
		<div id="content">
			<a id="top"></a>
			<div class="js-messagebox" id="mw-js-message" style="display:none;"></div>
						<!-- firstHeading -->
			<h1 id="firstHeading" class="firstHeading">Memory Allocation</h1>
			<!-- /firstHeading -->
			<!-- bodyContent -->
			<div id="bodyContent">
								<!-- tagline -->
				<div id="siteSub">From OSDev Wiki</div>
				<!-- /tagline -->
								<!-- subtitle -->
				<div id="contentSub"></div>
				<!-- /subtitle -->
																<!-- jumpto -->
				<div id="jump-to-nav">
					Jump to: <a href="#mw-head">navigation</a>,
					<a href="#p-search">search</a>
				</div>
				<!-- /jumpto -->
								<!-- bodycontent -->
				<div dir="ltr" class="mw-content-ltr" lang="en"><dl><dd><i>This page
 is about the allocation of memory from memory that is already available
 to the process (like malloc() and new()). For the allocation of page 
frames see <a href="http://wiki.osdev.org/Page_Frame_Allocation" title="Page Frame Allocation">Page Frame Allocation</a>.</i>
</dd></dl>
<p>One of the most basic functions of a <a href="http://wiki.osdev.org/Kernels" title="Kernels" class="mw-redirect">kernel</a> is the <a href="http://wiki.osdev.org/Memory_Management" title="Memory Management" class="mw-redirect">memory management</a>, i.e. the allocating and freeing of memory.
</p><p>At square one, the kernel is the only process in the system. But it is not alone: <a href="http://wiki.osdev.org/BIOS" title="BIOS">BIOS</a>
 data structures, memory-mapped hardware registers etc. populate the 
address space. Among the first things a kernel must do is to start 
bookkeeping about which areas of physical memory are available for use 
and which are to be considered "occupied".
</p><p>The free space will subsequently be used for kernel data structures, application binaries, their heap and <a href="http://wiki.osdev.org/Stack" title="Stack">stack</a>
 etc. - the kernel needs a function that marks a memory area as 
reserved, and makes that memory available to the process requiring it. 
In the C Standard Library, this is handled by malloc() and free(); in 
C++ by new() and delete().
</p>
<table id="toc" class="toc"><tbody><tr><td><div id="toctitle"><h2>Contents</h2><span class="toctoggle">&nbsp;[<a href="#" class="internal" id="togglelink">hide</a>]&nbsp;</span></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#A_very_very_simple_Memory_Manager"><span class="tocnumber">1</span> <span class="toctext">A very very simple Memory Manager</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="#Fixed_size_allocation"><span class="tocnumber">2</span> <span class="toctext">Fixed size allocation</span></a></li>
<li class="toclevel-1 tocsection-3"><a href="#Tips_to_go_further"><span class="tocnumber">3</span> <span class="toctext">Tips to go further</span></a></li>
<li class="toclevel-1 tocsection-4"><a href="#Memory_.26_Microkernels"><span class="tocnumber">4</span> <span class="toctext">Memory &amp; Microkernels</span></a></li>
<li class="toclevel-1 tocsection-5"><a href="#Porting_an_existing_Memory_Allocator"><span class="tocnumber">5</span> <span class="toctext">Porting an existing Memory Allocator</span></a>
<ul>
<li class="toclevel-2 tocsection-6"><a href="#Choosing_a_Memory_Allocator"><span class="tocnumber">5.1</span> <span class="toctext">Choosing a Memory Allocator</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-7"><a href="#See_Also"><span class="tocnumber">6</span> <span class="toctext">See Also</span></a>
<ul>
<li class="toclevel-2 tocsection-8"><a href="#Tutorials"><span class="tocnumber">6.1</span> <span class="toctext">Tutorials</span></a></li>
<li class="toclevel-2 tocsection-9"><a href="#External_Links"><span class="tocnumber">6.2</span> <span class="toctext">External Links</span></a></li>
</ul>
</li>
</ul>
</td></tr></tbody></table>
<h2> <span class="mw-headline" id="A_very_very_simple_Memory_Manager">A very very simple Memory Manager</span></h2>
<p>The easiest you can do is the WaterMark allocator. Just keep track of
 how far you've allocated and forget about the notion of "freeing".
</p>
<pre>           before ...
                                                          &lt;-N--&gt;
   +----+-----+--+--------//--+             +----+-----+--+----+---//--+
   |##A#|##B##|C#|  free      |             |##A#|##B##|C#|##D#|free   |
   +----+-----+--+---------//-+             +----+-----+--+----+---//--+
                 ^freebase    ^freetop                    ^d   ^fbase  ^ftop
</pre>
<p>When allocating N bytes for D, simply check that freetop-freebase&gt;N and increment freebase by N. Period.
A very simple Memory Manager
</p><p>Now, if you need to free things, one of the easiest solution is 
to put at the start of the freed zone a descriptor that allows you to 
insert it in a list of free zones. Keeping that list sorted by address 
helps you identifying contiguous free zones and allows you to merge them
 in larger free zones.
</p>
<pre>      first free                        Structure of a   +--.--.--.--+    +---&gt; +-- ...
        \/                              free zone        |F  R  E  E |    |     | FREE
   +----+-----+--+----+---+-----//--+                    |nextfreeptr|----+
   |##A#|free |C#|free|#E#|   free  |               &lt;----|prevfreeptr|
   +----+-|---+--+-|--+---+-----//--+                    | zone size |
          +-next&gt;--+                                     +///////////+
</pre>
<p><br>
</p>
<h2> <span class="mw-headline" id="Fixed_size_allocation">Fixed size allocation</span></h2>
<p>Allocating and deallocating fixed sized areas of memory is extremely 
simple. You can basically treat all free memory as a linked list of 
nodes. To allocate memory, you remove the front node from the linked 
list. To free memory, you return the front node to the linked list. This
 provides a constant allocation/releasing time and there is no 
fragmentation.
</p><p>In the real world, programs like to allocate different sized 
chunks of memory so it's unlikely you can solely rely on this method.
</p><p>However, it is theoretically possible for a microkernel to be 
designed so that all memory structures are exactly the same size (the 
Process struct, Thread struct, Message struct, etc). This would be very 
fast and efficient.
</p><p>On this note, most Lisp implementations have a single 
'box-and-pointer' base data type. A box-and-pointer type is a pair of 
values, usually pointer/pointer or atom/pointer (atom means a numeric 
value). On a 32-bit system, this structure is 8 bytes big. All other 
data structures (lists, trees, objects, etc) are built on top of this 
type. As a consequence memory allocation on a Lisp system is very fast.
</p>
<h2> <span class="mw-headline" id="Tips_to_go_further">Tips to go further</span></h2>
<ul><li> Sometimes, and especially when you're working with objects, you
 have to allocate many objects that always have a certain size. It is 
wise to create pools of pre-divided large blocks for such objects.
</li><li> It's way easier to keep the size of allocated objects in a header hidden from the requester, so that a call to <tt>free</tt> doesn't require the object's size. Normally this hidden header is kept just before the block returned by <tt>malloc</tt>.
</li><li> It's way easier to design a memory allocator in a host OS than
 in your kernel. Also, if you implement the full malloc interface (<tt>malloc</tt>, <tt>calloc</tt>, <tt>realloc</tt> and <tt>free</tt> is enough on Linux) a good sanity test is to compile your <tt>malloc</tt> into a shared library, then compile something (like your whole host OS tree) with your malloc using LD_PRELOAD.
</li><li> Magic words like "F R E E" and "U S E D" will make your life 
easier when debugging. TimRobinson even allows 32 bits to store the 
address of the requester so that you can see "okay, this is a N-bytes 
block that was requested by <tt>MySillyFunction()</tt>, line 3405" ...
</li></ul>
<h2> <span class="mw-headline" id="Memory_.26_Microkernels">Memory &amp; Microkernels</span></h2>
<p>In a <a href="http://wiki.osdev.org/Microkernel" title="Microkernel">microkernel</a>
 environment, there comes up a question: where the hell shall I put the 
memory management? In sense of heap management: give the kernel a 
dedicated allocator and a dedicated memory area to use - you might need 
two of them: one for the messages, and one for all the other stuff.
</p><p>The other task of memory management: Process address space 
management, keeping track of used pages (yes, lets talk about paging, it
 is nice, it is neat, it causes a warm fuzzy feeling beneath the toes) 
and assigning memory to processes as needed, you can split it up. To be 
more precise, you have to split this task up - or keep every aspect of 
memory management in kernel land to make it easy. A recommended method 
for managing process address space: handle it in a per-process-manner. 
The actual process needs memory: allocate the memory and hand it out to 
the process. So you can keep the page allocating routines easy and 
straight forward. For this task of allocating/deallocating memory, you 
should take into consideration, that the task performing such actions 
should be able to slip into address spaces at needs (it loads the 
required page directory and does what it has to do - slimy little weasel
 thou' it is.) Take those things into good consideration and put quite 
an amount of brainwork into them. It's worth doing good engineering 
here.
</p>
<h2> <span class="mw-headline" id="Porting_an_existing_Memory_Allocator">Porting an existing Memory Allocator</span></h2>
<p>It's not always desirable or practical to write your own memory 
allocator. Writing an efficient memory allocator can be an entire 
project in itself and fortunately it's extremely easy to port an 
existing memory allocator to your OS (to run in either kernel or user 
space). The advantages of using an existing memory allocator are; 
porting one is much faster than writing your own especially when you 
want to focus on other areas of your OS, it is likely to be well-tested 
so you do not have to debug the memory allocator, it takes a minimal 
amount of work to port it, and finally, someone else has down the hard 
work to make it fast, scalable, stable, etc.
</p><p>Porting a memory allocator is fairly simple to do. Most of them 
are no more than one source and/or header file. The functionality you 
must hook is for allocating and freeing pages to your program, so the 
memory allocator has memory to work with. Depending on the allocator 
you're using, there are two different pairs of hooks you will need to 
implement. For allocators that use the old UNIX way of requesting more 
program memory from the kernel you must hook/implement:
</p>
<ul><li>void *sbrk(size_t amount) - Increments the end of program's 
memory to by 'amount' bytes and returns a pointer to the beginning of 
the incremented amount. It doesn't matter if the amount requested 
doesn't line up with your page sizes or not, because you simply allocate
 enough pages to cover the amount requested, and then you subtract any 
leftover memory from 'amount' next time sbrk is called. Calling sbrk(0) 
returns a pointer to the end of the program's memory.
</li><li>int brk(void *end_data_segment) - Shrinks the programs memory 
to 'end_data_segment'. It releases all of the memory after 
'end_data_segment' back to the kernel. Just like with sbrk, 
'end_data_segment' does not have to line up with your page sizes.
</li></ul>
<p>There are also an alternative pair of hooks that some memory 
allocators use which allow the allocator to request memory from the 
kernel in terms of 'pages'. These memory allocators will have a constant
 stored somewhere in the source on how many large a page is (e.g. 
'#define PAGE_SIZE 4096' for 4KB pages) so the allocator knows how many 
pages to request at a time. With these allocators you must 
hook/implement:
</p>
<ul><li>void *alloc_page(int pages) - Allocates 'pages' consecutive 
pages in virtual memory and returns a pointer to the beginning of the 
group. Some allocators may allow you to return NULL or a magic value to 
indicate that the system or the program is out of memory, however do not
 assume you can return NULL/0 when failing as many allocators will 
actually think 0x0000 0000 is a valid address and try to allocate memory
 there.
</li><li>void free_page(void *start, int pages) - Frees 'pages' consecutive pages in virtual memory from 'start' back to the kernel.
</li></ul>
<p>In addition, some memory allocators will require you to hook locking 
functionality to ensure critical sections of the memory allocator aren't
 executed simultaneously by multiple threads. Typically the functions 
will appear like;
</p>
<ul><li>void wait_and_lock_mutex() - Locks a mutex before entering a 
critical section. The simplest 'lock' solution is to disable interrupts 
which may be suitable as a starting point. For best performance, it is 
recommended to implement a spin lock.
</li><li>void unlock_mutex() - Unlocks the mutex after leaving a 
critical section. You either enable interrupts again or reset the spin 
lock. This allows any waiting threads to enter the critical section.
</li></ul>
<h3> <span class="mw-headline" id="Choosing_a_Memory_Allocator">Choosing a Memory Allocator</span></h3>
<p>There are many memory allocators to choose from. There is no perfect 
memory allocator because there are many different goals different 
allocators try to achieve. Usually these are conflicting goals, so 
different allocators have different trade-offs.
</p><p>Some allocators are;
</p>
<ul><li>..fast. They can perform the most allocations and releases per 
second. 'Fast' is context sensitive, and an allocator that is fast when 
in some circumstances (allocating lots of large chunks) may not be in 
other circumstances (allocating and releasing lots of small chunks).
</li></ul>
<ul><li>..space efficient. While other allocators may be aligning memory
 to page boundaries or have huge internal structures taking up 
megabytes, these allocators make sure all memory is packed into it's 
tightest fitting area and no byte is left to waste. This is especially 
important if you do not have much RAM.
</li></ul>
<ul><li>..stable. The other allocators may be fast, but these allocators
 are designed to run for a very long time. They focus on minimising 
memory fragmentation, which is important for a server that runs for 
months on end.
</li></ul>
<ul><li>..scalable. There are other allocators that are faster when 
allocating from a single thread but other threads must lock and wait for
 their turn. Scalable allocators can handle allocations from hundreds of
 threads on the latest quad-core CPUs concurrently with no significant 
performance penalty and minimal locking.
</li></ul>
<ul><li>..real-time. There may be a fast allocator that on 'average' 
takes 75 cycles to allocate a chunk, but has the occasional worse case 
situation where it'll take 350 cycles. A real-time allocator might 
guarantee to return a memory pointer in less than 200 cycles. This is 
desirable in media decoding and real-time systems.
</li></ul>
<p>There are a lot of allocators to choose from, so this is far from being a comprehensive list;
</p>
<ul><li>liballoc - Excellent allocator that was part of the Spoon 
Operating System and designed to be plugged into hobby OS's. 
Unfortunately it is no longer available.
</li><li><a rel="nofollow" class="external text" href="http://g.oswego.edu/dl/html/malloc.html">dlmalloc</a> - Doug Lea's Memory Allocator. A good all purpose memory allocator that is widely used and ported.
</li><li><a rel="nofollow" class="external text" href="http://goog-perftools.sourceforge.net/doc/tcmalloc.html">TCMalloc</a> Thread-Caching Malloc. An experimental scalable allocator.
</li><li><a rel="nofollow" class="external text" href="http://www.nedprod.com/programs/portable/nedmalloc/">nedmalloc</a>
 A very fast and very scalable allocator. These two properties have made
 it somewhat popular in multi-threaded video games as an alternative to 
the default provided allocator.
</li><li><a rel="nofollow" class="external text" href="http://www.malloc.de/en/">ptmalloc</a> A widely used memory allocator included with glibc that scales reasonably while being space efficient.
</li></ul>
<h2> <span class="mw-headline" id="See_Also">See Also</span></h2>
<h3> <span class="mw-headline" id="Tutorials">Tutorials</span></h3>
<ul><li><a href="http://wiki.osdev.org/Writing_a_memory_manager" title="Writing a memory manager">Writing a memory manager</a>
</li></ul>
<h3> <span class="mw-headline" id="External_Links">External Links</span></h3>
<ul><li><a rel="nofollow" class="external text" href="http://www.osdever.net/tutorials/memory1.php?the_id=44">Memory Management 1</a> - Part one of a two part series on memory management by Tim Robinson
</li><li><a rel="nofollow" class="external text" href="http://www.osdever.net/tutorials/memory2.php?the_id=45">Memory Management 2</a> - Part two of a two part series on memory management by Tim Robinson
</li><li><a rel="nofollow" class="external text" href="http://www.cs.ucsb.edu/%7Egrze/papers/Keyword/MEMORY-MANAGEMENT.html">Publications about 'Memory Management'</a> - A list of some nice articles
</li><li><a rel="nofollow" class="external text" href="http://rtportal.upv.es/rtmalloc/">TLSF: Memory Allocator for Real-Time</a> General purpose dynamic memory allocator specifically designed to meet real-time requirements
</li></ul>

<!-- 
NewPP limit report
Preprocessor node count: 61/1000000
Post-expand include size: 0/2097152 bytes
Template argument size: 0/2097152 bytes
Expensive parser function count: 0/100
-->

<!-- Saved in parser cache with key wikidb:pcache:idhash:1460-0!*!0!!en!*!* and timestamp 20130612172038 -->
</div>				<!-- /bodycontent -->
								<!-- printfooter -->
				<div class="printfooter">
				Retrieved from "<a href="http://wiki.osdev.org/index.php?title=Memory_Allocation&amp;oldid=13057">http://wiki.osdev.org/index.php?title=Memory_Allocation&amp;oldid=13057</a>"				</div>
				<!-- /printfooter -->
												<!-- catlinks -->
				<div id="catlinks" class="catlinks"><div id="mw-normal-catlinks"><a href="http://wiki.osdev.org/Special:Categories" title="Special:Categories">Category</a>: <ul><li><a href="http://wiki.osdev.org/Category:Memory_management" title="Category:Memory management">Memory management</a></li></ul></div></div>				<!-- /catlinks -->
												<div class="visualClear"></div>
				<!-- debughtml -->
								<!-- /debughtml -->
			</div>
			<!-- /bodyContent -->
		</div>
		<!-- /content -->
		<!-- header -->
		<div id="mw-head" class="noprint">
			
<!-- 0 -->
<div id="p-personal" class="">
	<h5>Personal tools</h5>
	<ul>
		<li id="pt-login"><a href="http://wiki.osdev.org/index.php?title=Special:UserLogin&amp;returnto=Memory_Allocation" title="You are encouraged to log in; however, it is not mandatory [alt-shift-o]" accesskey="o">Log in</a></li>
	</ul>
</div>

<!-- /0 -->
			<div id="left-navigation">
				
<!-- 0 -->
<div id="p-namespaces" class="vectorTabs">
	<h5>Namespaces</h5>
	<ul>
					<li id="ca-nstab-main" class="selected"><span><a href="http://wiki.osdev.org/Memory_Allocation" title="View the content page [alt-shift-c]" accesskey="c">Page</a></span></li>
					<li id="ca-talk" class="new"><span><a href="http://wiki.osdev.org/index.php?title=Talk:Memory_Allocation&amp;action=edit&amp;redlink=1" title="Discussion about the content page [alt-shift-t]" accesskey="t">Discussion</a></span></li>
			</ul>
</div>

<!-- /0 -->

<!-- 1 -->
<div id="p-variants" class="vectorMenu emptyPortlet">
		<h5><span>Variants</span><a href="#"></a></h5>
	<div class="menu">
		<ul>
					</ul>
	</div>
</div>

<!-- /1 -->
			</div>
			<div id="right-navigation">
				
<!-- 0 -->
<div id="p-views" class="vectorTabs">
	<h5>Views</h5>
	<ul>
					<li id="ca-view" class="selected"><span><a href="http://wiki.osdev.org/Memory_Allocation">Read</a></span></li>
					<li id="ca-viewsource"><span><a href="http://wiki.osdev.org/index.php?title=Memory_Allocation&amp;action=edit" title="This page is protected.
You can view its source [alt-shift-e]" accesskey="e">View source</a></span></li>
					<li id="ca-history" class="collapsible"><span><a href="http://wiki.osdev.org/index.php?title=Memory_Allocation&amp;action=history" title="Past revisions of this page [alt-shift-h]" accesskey="h">View history</a></span></li>
			</ul>
</div>

<!-- /0 -->

<!-- 1 -->
<div id="p-cactions" class="vectorMenu emptyPortlet">
	<h5><span>Actions</span><a href="#"></a></h5>
	<div class="menu">
		<ul>
					</ul>
	</div>
</div>

<!-- /1 -->

<!-- 2 -->
<div id="p-search">
	<h5><label for="searchInput">Search</label></h5>
	<form action="/index.php" id="searchform">
		<input name="title" value="Special:Search" type="hidden">
				<input name="search" title="Search OSDev Wiki [alt-shift-f]" accesskey="f" id="searchInput" type="search">		<input name="go" value="Go" title="Go to a page with this exact name if exists" id="searchGoButton" class="searchButton" type="submit">		<input name="fulltext" value="Search" title="Search the pages for this text" id="mw-searchButton" class="searchButton" type="submit">			</form>
</div>

<!-- /2 -->
			</div>
		</div>
		<!-- /header -->
		<!-- panel -->
			<div id="mw-panel" class="noprint">
				<!-- logo -->
					<div id="p-logo"><a style="background-image: url(/skins/common/images/osdev.png);" href="http://wiki.osdev.org/Main_Page" title="Visit the main page"></a></div>
				<!-- /logo -->
				
<!-- navigation -->
<div class="portal" id="p-navigation">
	<h5>Navigation</h5>
	<div class="body">
		<ul>
			<li id="n-mainpage"><a href="http://wiki.osdev.org/Main_Page" title="Visit the main page [alt-shift-z]" accesskey="z">Main Page</a></li>
			<li id="n-portal"><a href="http://forum.osdev.org/" rel="nofollow" title="About the project, what you can do, where to find things">Forums</a></li>
			<li id="n-FAQ"><a href="http://wiki.osdev.org/Category:FAQ">FAQ</a></li>
			<li id="n-OS-Projects"><a href="http://wiki.osdev.org/Projects">OS Projects</a></li>
			<li id="n-randompage"><a href="http://wiki.osdev.org/Special:Random" title="Load a random page [alt-shift-x]" accesskey="x">Random page</a></li>
		</ul>
	</div>
</div>

<!-- /navigation -->

<!-- about -->
<div class="portal" id="p-about">
	<h5>About</h5>
	<div class="body">
		<ul>
			<li id="n-This-site"><a href="http://wiki.osdev.org/OSDevWiki:About">This site</a></li>
			<li id="n-Joining"><a href="http://wiki.osdev.org/OSDevWiki:Joining">Joining</a></li>
			<li id="n-Editing-help"><a href="http://wiki.osdev.org/OSDevWiki:Editing">Editing help</a></li>
			<li id="n-recentchanges"><a href="http://wiki.osdev.org/Special:RecentChanges" title="A list of recent changes in the wiki [alt-shift-r]" accesskey="r">Recent changes</a></li>
		</ul>
	</div>
</div>

<!-- /about -->

<!-- SEARCH -->

<!-- /SEARCH -->

<!-- TOOLBOX -->
<div class="portal" id="p-tb">
	<h5>Toolbox</h5>
	<div class="body">
		<ul>
			<li id="t-whatlinkshere"><a href="http://wiki.osdev.org/Special:WhatLinksHere/Memory_Allocation" title="A list of all wiki pages that link here [alt-shift-j]" accesskey="j">What links here</a></li>
			<li id="t-recentchangeslinked"><a href="http://wiki.osdev.org/Special:RecentChangesLinked/Memory_Allocation" title="Recent changes in pages linked from this page [alt-shift-k]" accesskey="k">Related changes</a></li>
			<li id="t-specialpages"><a href="http://wiki.osdev.org/Special:SpecialPages" title="A list of all special pages [alt-shift-q]" accesskey="q">Special pages</a></li>
			<li><a href="http://wiki.osdev.org/index.php?title=Memory_Allocation&amp;printable=yes" rel="alternate">Printable version</a></li>
			<li id="t-permalink"><a href="http://wiki.osdev.org/index.php?title=Memory_Allocation&amp;oldid=13057" title="Permanent link to this revision of the page">Permanent link</a></li>
		</ul>
	</div>
</div>

<!-- /TOOLBOX -->

<!-- LANGUAGES -->

<!-- /LANGUAGES -->
			</div>
		<!-- /panel -->
		<!-- footer -->
		<div id="footer">
							<ul id="footer-info">
											<li id="footer-info-lastmod"> This page was last modified on 21 March 2012, at 23:33.</li>
											<li id="footer-info-viewcount">This page has been accessed 37,768 times.</li>
									</ul>
							<ul id="footer-places">
											<li id="footer-places-privacy"><a href="http://wiki.osdev.org/OSDev_Wiki:Privacy_policy" title="OSDev Wiki:Privacy policy">Privacy policy</a></li>
											<li id="footer-places-about"><a href="http://wiki.osdev.org/OSDev_Wiki:About" title="OSDev Wiki:About">About OSDev Wiki</a></li>
											<li id="footer-places-disclaimer"><a href="http://wiki.osdev.org/OSDev_Wiki:General_disclaimer" title="OSDev Wiki:General disclaimer">Disclaimers</a></li>
									</ul>
										<ul id="footer-icons" class="noprint">
					<li id="footer-poweredbyico">
						<a href="http://www.mediawiki.org/"><img src="Memory%20Allocation%20-%20OSDev%20Wiki_files/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" height="31" width="88"></a>
					</li>
				</ul>
						<div style="clear:both"></div>
		</div>
		<!-- /footer -->
		<!-- fixalpha -->
		<script type="text/javascript"> if ( window.isMSIE55 ) fixalpha(); </script>
		<!-- /fixalpha -->
		<script src="Memory%20Allocation%20-%20OSDev%20Wiki_files/load_006.php"></script>
<script>if(window.mw){
	mw.loader.load(["mediawiki.user", "mediawiki.util", "mediawiki.page.ready", "mediawiki.legacy.wikibits", "mediawiki.legacy.ajax"]);
}
</script><script type="text/javascript" src="Memory%20Allocation%20-%20OSDev%20Wiki_files/load_004.php"></script>
<script src="Memory%20Allocation%20-%20OSDev%20Wiki_files/load_005.php"></script>
<script>if(window.mw){
	mw.user.options.set({"ccmeonemails":0,"cols":80,"date":"default","diffonly":0,"disablemail":0,"disablesuggest":0,"editfont":"default","editondblclick":0,"editsection":1,"editsectiononrightclick":0,"enotifminoredits":0,"enotifrevealaddr":0,"enotifusertalkpages":1,"enotifwatchlistpages":0,"extendwatchlist":0,"externaldiff":0,"externaleditor":0,"fancysig":0,"forceeditsummary":0,"gender":"unknown","hideminor":0,"hidepatrolled":0,"highlightbroken":1,"imagesize":2,"justify":0,"math":1,"minordefault":0,"newpageshidepatrolled":0,"nocache":0,"noconvertlink":0,"norollbackdiff":0,"numberheadings":0,"previewonfirst":0,"previewontop":1,"quickbar":5,"rcdays":7,"rclimit":50,"rememberpassword":0,"rows":25,"searchlimit":20,"showhiddencats":0,"showjumplinks":1,"shownumberswatching":1,"showtoc":1,"showtoolbar":1,"skin":"vector","stubthreshold":0,"thumbsize":2,"underline":2,"uselivepreview":0,"usenewrc":0,"watchcreations":0,"watchdefault":0,"watchdeletion":0,"watchlistdays":3,"watchlisthideanons":0,
	"watchlisthidebots":0,"watchlisthideliu":0,"watchlisthideminor":0,"watchlisthideown":0,"watchlisthidepatrolled":0,"watchmoves":0,"wllimit":250,"variant":"en","language":"en","searchNs0":true,"searchNs1":false,"searchNs2":false,"searchNs3":false,"searchNs4":false,"searchNs5":false,"searchNs6":false,"searchNs7":false,"searchNs8":false,"searchNs9":false,"searchNs10":false,"searchNs11":false,"searchNs12":false,"searchNs13":false,"searchNs14":false,"searchNs15":false});;mw.user.tokens.set({"editToken":"+\\","watchToken":false});;mw.loader.state({"user.options":"ready","user.tokens":"ready"});
	
	/* cache key: wikidb:resourceloader:filter:minify-js:4:19a4b18a9ac79a6b8c60b24af4668814 */
}
</script><!-- Served in 0.206 secs. -->
	

</body></html>